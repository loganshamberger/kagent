#!/usr/bin/env python3
"""
Secure Device Authentication - PoC
Simulates a human-only secure device that:
1. Generates daily Hex-16 codes
2. Stores the Gold Code (never shared with agent)
3. Creates zero-knowledge proofs for authentication
4. Never outputs secrets to untrusted channels
"""

import hashlib
import hmac
import json
from datetime import datetime
from typing import Dict, Optional


class SecureDevice:
    """
    Hardware/secure device that stores human secrets.
    
    Invariants:
    - Gold Code is NEVER transmitted outside this device
    - Proofs are created HERE, not on agent
    - User controls when/if proofs are sent to agent
    - Daily Hex-16 codes are generated by human + device
    """

    def __init__(self, gold_code: str, device_id: str = "SECURE_DEVICE_001"):
        """Initialize secure device with Gold Code"""
        self.gold_code = gold_code
        self.device_id = device_id
        self.proof_log = []

        print(f"[SECURE DEVICE] Initialized: {device_id}")
        print(f"[SECURE DEVICE] Gold Code: {'*' * len(gold_code)}")

    def generate_daily_hex16(self, date_str: Optional[str] = None) -> str:
        """
        Generate or retrieve today's Hex-16 code.
        
        In production:
        - User enters a code from a physical token
        - Or code is derived from a secure seed + date
        - Here we simulate with date-based derivation
        """
        if date_str is None:
            date_str = datetime.utcnow().strftime("%Y-%m-%d")

        # In real system: user enters this from a hardware token (TOTP-like)
        hex16 = hashlib.sha256(f"daily_seed_{date_str}".encode()).hexdigest()[:32]
        return hex16

    def create_proof(
        self, challenge_id: str, hex16_code: str, nonce: str
    ) -> Dict[str, str]:
        """
        Create a zero-knowledge proof of authentication.
        
        Proof = H(Gold Code || Hex-16 || Nonce)
        Signature = HMAC-SHA256(Gold Code, Proof)
        
        Returns only the proof and signature - not the Gold Code!
        """
        print(f"\n[SECURE DEVICE] Creating proof for challenge: {challenge_id}")
        print(f"[SECURE DEVICE] User entered Hex-16: {hex16_code}")

        # Construct input using Gold Code (only on secure device)
        proof_input = f"{self.gold_code}||{hex16_code}||{nonce}"

        # Hash it (commitment to the values)
        proof_hash = hashlib.sha256(proof_input.encode()).hexdigest()

        # Sign the proof with Gold Code (HMAC acts as proof of possession)
        signature = hmac.new(
            self.gold_code.encode(),
            msg=proof_hash.encode(),
            digestmod="sha256",
        ).hexdigest()

        proof = {
            "challenge_id": challenge_id,
            "proof_hash": proof_hash,
            "signature": signature,
        }

        self.proof_log.append(
            {
                "timestamp": datetime.utcnow().isoformat(),
                "challenge_id": challenge_id,
                "proof_hash": proof_hash,
                "device_id": self.device_id,
            }
        )

        print(f"[SECURE DEVICE] Proof created successfully")
        print(f"[SECURE DEVICE] Proof hash: {proof_hash[:16]}...")
        print(f"[SECURE DEVICE] (Gold Code is NOT in this proof)")

        return proof

    def validate_challenge(self, challenge: Dict[str, str]) -> bool:
        """
        Validate that a challenge is legitimate before creating proof.
        User reviews the action being authenticated.
        """
        print(f"\n[SECURE DEVICE] Challenge validation:")
        print(f"  Challenge ID: {challenge['challenge_id']}")
        print(f"  Timestamp: {challenge['timestamp']}")
        print(f"  Expires: {challenge['expires_at']}")

        # In production: display to user for confirmation
        # "Do you want to authorize deleting the production database? [Y/N]"

        return True

    def send_proof_to_agent(self, proof: Dict[str, str], agent_channel) -> bool:
        """
        Securely transmit proof to agent.
        In production: secure channel (TLS, encrypted, authenticated)
        """
        print(f"\n[SECURE DEVICE] Sending proof to agent via secure channel...")
        print(f"[SECURE DEVICE] Note: Gold Code STAYS on this device")

        return True

    def get_proof_log(self) -> list:
        """Audit log of all proofs created"""
        return self.proof_log


# ============================================================================
# WORKFLOW SIMULATION
# ============================================================================

class AuthenticationWorkflow:
    """
    Orchestrates the full authentication flow between agent, gatekeeper, and secure device.
    Shows the complete security boundary.
    """

    def __init__(self, agent, gatekeeper, secure_device):
        self.agent = agent
        self.gatekeeper = gatekeeper
        self.device = secure_device

    def handle_blocked_action(self, action: str, params: Dict) -> bool:
        """
        Complete workflow when agent attempts unsafe action:
        1. Agent blocked by gatekeeper
        2. Challenge issued
        3. Human reviews on secure device
        4. Proof created (Gold Code stays secret)
        5. Proof sent to agent (agent still doesn't know Gold Code)
        6. Agent submits proof for retry
        """
        print("\n" + "=" * 70)
        print("AUTHENTICATION WORKFLOW START")
        print("=" * 70)

        # Step 1: Agent attempts unsafe action
        print("\n[STEP 1] Agent attempts unsafe action")
        response = self.agent.execute_action(action, params)

        if response.get("status") != "blocked":
            print("[WORKFLOW] Action was allowed, no auth needed")
            return True

        # Step 2: Challenge issued
        if "challenge" not in response:
            print("[WORKFLOW] ERROR: No challenge in response")
            return False

        challenge = response["challenge"]
        challenge_id = challenge["challenge_id"]
        hex16_code = challenge["hex16_code"]
        nonce = challenge["nonce"]

        print(f"\n[STEP 2] Challenge issued: {challenge_id}")

        # Step 3: Human reviews challenge on secure device
        print(f"\n[STEP 3] Human reviews challenge on secure device")
        if not self.device.validate_challenge(challenge):
            print("[WORKFLOW] User denied authentication")
            return False

        # Step 4: Secure device creates proof
        print(f"\n[STEP 4] Secure device creates zero-knowledge proof")
        proof = self.device.create_proof(challenge_id, hex16_code, nonce)

        # Step 5: Proof sent to agent
        print(f"\n[STEP 5] Secure device sends proof to agent")
        self.device.send_proof_to_agent(proof, self.agent)

        # Step 6: Agent submits proof
        print(f"\n[STEP 6] Agent submits proof for retry")
        final_response = self.agent.submit_proof(challenge_id, proof)

        success = final_response.get("status") == "allowed"

        print("\n" + "=" * 70)
        if success:
            print("WORKFLOW SUCCESS: Action authenticated and allowed")
        else:
            print("WORKFLOW FAILED: Authentication unsuccessful")
        print("=" * 70)

        return success


# ============================================================================
# DEMO
# ============================================================================

if __name__ == "__main__":
    from gatekeeper_server import GatekeeperMCPServer
    from agent_client import AgentClient

    print("=" * 70)
    print("SECURE DEVICE AUTHENTICATION - FULL WORKFLOW PoC")
    print("=" * 70)

    # Initialize components
    gatekeeper = GatekeeperMCPServer()
    agent = AgentClient(gatekeeper)
    secure_device = SecureDevice(
        gold_code="super_secret_gold_code_12345", device_id="HARDWARE_TOKEN_001"
    )

    workflow = AuthenticationWorkflow(agent, gatekeeper, secure_device)

    # Scenario 1: Delete database (requires auth)
    print("\n" + "=" * 70)
    print("SCENARIO 1: Agent attempts to delete production database")
    print("=" * 70)
    workflow.handle_blocked_action("delete_database", {"db": "production"})

    # Scenario 2: Access credentials (requires auth)
    print("\n" + "=" * 70)
    print("SCENARIO 2: Agent attempts to access credentials")
    print("=" * 70)
    workflow.handle_blocked_action(
        "access_credentials", {"service": "aws", "region": "us-east-1"}
    )

    # Show audit log
    print("\n" + "=" * 70)
    print("SECURE DEVICE AUDIT LOG")
    print("=" * 70)
    print(json.dumps(secure_device.get_proof_log(), indent=2))

    print("\n" + "=" * 70)
    print("KEY SECURITY PROPERTIES")
    print("=" * 70)
    print("""
✓ Gold Code NEVER leaves the secure device
✓ Gold Code NEVER transmitted to agent
✓ Proofs are zero-knowledge (can't reverse to get Gold Code)
✓ Agent is physically incapable of forging proofs
✓ All proofs require human approval + daily Hex-16
✓ Audit trail of all authentication events
✓ Prompt injections cannot bypass security (Gold Code is inaccessible)
✓ Hallucinations cannot access protected resources

CRYPTOGRAPHIC AIR-GAP:
- Agent runs on untrusted machine
- Secure device runs on trusted hardware
- Communication is authenticated but secrets never cross boundary
- Human is the only entity that knows both Gold Code and Hex-16
    """)
